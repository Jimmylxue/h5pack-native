!(function (e, t) {
  'object' == typeof exports && 'undefined' != typeof module
    ? t(exports)
    : 'function' == typeof define && define.amd
    ? define(['exports'], t)
    : t(
        ((e =
          'undefined' != typeof globalThis
            ? globalThis
            : e || self).H5PackBridge = {}),
      );
})(this, function (e) {
  'use strict';
  class t {
    h5packBridge;
    moduleName;
    constructor(e, t) {
      (this.h5packBridge = e), (this.moduleName = t);
    }
    async call(e, t) {
      return this.h5packBridge.callNative(this.moduleName, e, t);
    }
    handleError(e, t = 'Operation failed') {
      throw (
        (console.error(`[${this.moduleName}] Error:`, e),
        new Error(e.message || t))
      );
    }
  }
  class a extends t {
    constructor(e) {
      super(e, 'camera');
    }
    async open(e) {
      const t = {
        cameraType: e.cameraType || 'back',
        mediaType: 'photo',
        saveToPhotos: !1,
        ...e,
      };
      try {
        return await this.call('open', t);
      } catch (e) {
        return this.handleError(e, 'Failed to open camera');
      }
    }
    async chooseImage(e = {}) {
      const t = {
        mediaType: 'photo',
        includeBase64: e?.includeBase64 || !1,
        maxWidth: e?.maxWidth || 1024,
        maxHeight: e?.maxHeight || 1024,
        quality: e?.quality || 0.8,
        selectionLimit: e?.selectionLimit || 9,
        ...e,
      };
      try {
        return await this.call('chooseImage', t);
      } catch (e) {
        return this.handleError(e, 'Failed to open camera');
      }
    }
    async checkPermission() {
      try {
        return await this.call('checkPermission');
      } catch (e) {
        return this.handleError(e, 'Failed to check camera permission');
      }
    }
    async requestPermission() {
      try {
        return await this.call('requestPermission');
      } catch (e) {
        return this.handleError(e, 'Failed to request camera permission');
      }
    }
  }
  const r = new (class {
    callbacks = new Map();
    modules = {};
    isAvailable = !1;
    constructor() {
      'undefined' != typeof window &&
        window.ReactNativeWebView &&
        (this.isAvailable = !0),
        this.setupEventListeners();
    }
    get camera() {
      return this.modules.camera;
    }
    get location() {
      return this.modules.location;
    }
    registerModule(e, t) {
      this.modules[e] = t;
    }
    getModule(e) {
      return this.modules?.[e];
    }
    callNative(e, t, a) {
      return new Promise((r, i) => {
        if (!this.isAvailable)
          return void i(new Error('Native bridge not available'));
        const s = `call_${Date.now()}_${Math.random()
            .toString(36)
            .substr(2, 9)}`,
          o = setTimeout(() => {
            this.cleanupCallback(s), i(new Error('Bridge call timeout'));
          }, 3e4);
        this.callbacks.set(s, {resolve: r, reject: i, timeoutId: o});
        const n = {
          type: 'bridge_call',
          callId: s,
          module: e,
          action: t,
          params: a,
          timestamp: Date.now(),
        };
        window.ReactNativeWebView.postMessage(JSON.stringify(n));
      });
    }
    setupEventListeners() {
      window.ReactNativeWebView &&
        document.addEventListener('message', this.handleNativeMessage),
        window.addEventListener('message', this.handleNativeMessage);
    }
    handleNativeMessage = e => {
      try {
        const t = JSON.parse(e.data);
        if ('bridge_response' === t.type) {
          const {callId: e, success: a, data: r, error: i} = t,
            s = this.callbacks.get(e);
          s &&
            (this.cleanupCallback(e),
            a ? s.resolve(r) : s.reject(new Error(i || 'Native call failed')));
        }
      } catch (e) {
        console.error('Failed to handle native message:', e);
      }
    };
    cleanupCallback(e) {
      const t = this.callbacks.get(e);
      t && (clearTimeout(t.timeoutId), this.callbacks.delete(e));
    }
  })();
  r.registerModule('camera', new a(r)),
    r.registerModule(
      'location',
      new (class extends t {
        constructor(e) {
          super(e, 'location');
        }
        async getCurrentPosition(e = {}) {
          const t = {enableHighAccuracy: !1, maximumAge: 0, ...e};
          try {
            return await this.call('getCurrentPosition', t);
          } catch (e) {
            return this.handleError(e, 'Failed to get current location');
          }
        }
      })(r),
    ),
    'undefined' != typeof window && (window.h5packBridge = r),
    (e.CameraModule = a),
    (e.default = r),
    (e.h5packBridge = r),
    Object.defineProperty(e, '__esModule', {value: !0});
});
